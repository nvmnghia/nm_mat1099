\documentclass[../../Lectures]{subfiles}


\begin{document}

\chapter{Giải hệ phương trình}

Chúng ta có 2 loại hệ phương trình:
\begin{itemize}
    \item Hệ phương trình tuyến tính
    \item Hệ phương trình phi tuyến
\end{itemize}

Chúng ta đã biết các phương pháp giải trực tiếp và gián tiếp hệ phương trình
tuyến tính:
\begin{itemize}
    \item Các phương pháp giải trực tiếp:
        \begin{itemize}
            \item Phương pháp Cramer
            \item Phương pháp thế
            \item Phương pháp sử dụng ma trận nghịch đảo
            \item \hyperref[method:gauss_elimination]{Phương pháp khử Gauss},
                Gauss-Jordan
        \end{itemize}

    \item Các phương pháp giải gián tiếp
        \begin{itemize}
            \item Phương pháp lặp đơn
            \item Phương pháp lặp Seidel
        \end{itemize}

    \item Các phương pháp tìm trị riêng và véc tơ riêng của ma trận
\end{itemize}


%----------------------------------------------------------------------------------------
%	3.1: Đặt bài toán và phương pháp giải
%----------------------------------------------------------------------------------------

\section{Đặt bài toán và phương pháp giải}

Hệ phương trình tuyến tính \(n\) phương trình, \(n\) ẩn \(x_1\), \(x_2\),
\ldots, \(x_n\) là tập \(n\) phương trình \(E_1\), \(E_2\), \ldots , \(E_n\)
dạng
\[\label{eq:general_system_equations}
    \begin{cases}
        E_1 \text{ : } a_{11} x_1 + a_{12} x_2 + \ldots + a_{1n} x_n = b_1 \\
        E_2 \text{ : } a_{21} x_1 + a_{22} x_2 + \ldots + a_{2n} x_n = b_2 \\
        \ldots \\
        E_n \text{ : } a_{n1} x_1 + a_{n2} x_2 + \ldots + a_{nn} x_n = b_n \\
    \end{cases}
\]
với các hệ số \(a_{jk}\) và \(b_j\) đã biết. Hệ được gọi là thuần nhất nếu các
\(b_j\) bằng \(0\), trong trường hợp ngược lại được gọi là hệ không thuần nhất.

Dùng cách biểu diễn ma trận, ta có thể viết hệ
\eqref{eq:general_system_equations} dưới dạng:
\begin{equation}\label{eq:general_system_equations_in_matrix}
    \bm{A x} = \bm{b}
\end{equation}

Ở đây, ma trận hệ số \(A = [a_{jk}]\) là ma trận vuông cấp \(n\), \(x\) và \(b\)
là các véc tơ cột:
\[
    \bm{A} =
        \begin{pmatrix}
            a_{11}  &  a_{12}  &  \dots   &  a_{1n}  \\
            a_{21}  &  a_{22}  &  \dots   &  a_{2n}  \\
            \vdots  &  \vdots  &  \ddots  &  \vdots  \\
            a_{n1}  &  a_{n2}  &  \dots   &  a_{nn}  \\
        \end{pmatrix} \quad
    \bm{x} =
        \begin{pmatrix}
            x_1     \\
            x_2     \\
            \vdots  \\
            x_n     \\
        \end{pmatrix} \quad
    \bm{b} =
        \begin{pmatrix}
            b_1     \\
            b_2     \\
            \vdots  \\
            b_n     \\
        \end{pmatrix}
\]

Ma trận \(\bm{\tilde{A}}\) sau được gọi là ma trận mở rộng (augmented matrix)
của hệ \eqref{eq:general_system_equations}:
\[
    \bm{\tilde{A}} = [\bm{A}, \bm{b}] =
        \begin{pNiceArray}{cccc:c}
            a_{11}  &  a_{12}  &  \dots   &  a_{1n}  &  b_1     \\
            a_{21}  &  a_{22}  &  \dots   &  a_{2n}  &  b_2     \\
            \vdots  &  \vdots  &  \ddots  &  \vdots  &  \vdots  \\
            a_{n1}  &  a_{n2}  &  \dots   &  a_{nn}  &  b_n     \\
        \end{pNiceArray}
\]

Nghiệm của \eqref{eq:general_system_equations} là bộ số \(x_1\), \(x_2\),
\ldots, \(x_n\) thỏa mãn tất cả phương trình của hệ.

Véc tơ nghiệm của \eqref{eq:general_system_equations} là \(\bm{x}\) mà các thành
phần của nó lập thành một nghiệm của \eqref{eq:general_system_equations}.

Hệ phương trình \eqref{eq:general_system_equations} có thể giải được bằng
\begin{itemize}
    \item \emph{phương pháp trực tiếp}
        (\hyperref[method:gauss_elimination]{phương pháp khử Gauss}, \ldots),
        hoặc
    \item \emph{phương pháp gián tiếp} hay \emph{phương pháp lặp}
\end{itemize}


%----------------------------------------------------------------------------------------
%	3.2: Phương pháp khử Gauss
%----------------------------------------------------------------------------------------

\section{Phương pháp khử Gauss}\label{sec:gauss_elimination}

Chúng ta đã biết phương pháp sử dụng định thức để giải hệ phương trình
\eqref{eq:general_system_equations}, đó là \emph{phương pháp Cramer}. Ở đây ta
xét \emph{phương pháp khử Gauss}, cũng là một phương pháp trực tiếp, để giải hệ
phương trình tuyến tính.

\subsection{Phương pháp khử Gauss}

\begin{cmethod}{Phương pháp khử Gauss}{gauss_elimination}
    Phương pháp này khử liên tiếp các ẩn để từng bước đưa ma trận mở rộng
    \(\bm{\tilde{A}}\) về dạng tam giác trên (upper triangular matrix, hay dạng
    bậc thang).

    Phương pháp gồm hai phần thực hiện lần lượt như sau:

    \begin{enumerate}
        \item \emph{Quá trình thuận (forward elimination)}: Dùng các phép biến
            đổi hàng sơ cấp để đưa \(\bm{\tilde{A}}\) về dạng tam giác trên:
            \begin{enumerate}
                \item Khử \(x_1\) từ \(E_{\geq 2}\) bằng cách:
                    \begin{equation}\label{eq:gauss_elinimation_1st}
                        E_j \coloneqq E_j - \frac{a_{j1}}{a_{11}} E_1 \, \forall j \in \interval{2}{n}
                    \end{equation}

                    \(a_{11}\) gọi là \emph{phần tử trục xoay (pivot)}, \(E_1\)
                    gọi là \emph{phương trình chính (pivot equation)}.

                \item Với \(i = 2, \ldots, n - 1\), khử \(x_i\) từ \(E_{> i}\)
                    bằng cách tương tự như trên, cuối cùng thu được dạng tam
                    giác trên.
            \end{enumerate}

        \item \emph{Quá trình ngược (back substitution)}: Giải \(\bm{x}\) từ
            cuối lên:
            \begin{enumerate}
                \item Giải \(x_n\) từ \(E_n\), giải tiếp được \(x_{n - 1}\) do
                    đã biết \(x_n\).

                \item Tương tự giải được đến \(x_1\), cuối cùng thu được nghiệm
                    \(\bm{x}\).
            \end{enumerate}
    \end{enumerate}
\end{cmethod}

(\emph{``back''} trong cụm \emph{``back substitution''} nghĩa là các ẩn được
giải từ cuối lên, do trước đó đã đưa được \(\bm{A}\) về dạng tam giác trên.
Tương tự, nếu \(\bm{A}\) ở dạng tam giác dưới, việc thế từ trên xuống sẽ gọi là
\emph{``forward substitution''}. Dù hai dạng này tương đương, trong khử Gauss ta
chỉ nói đến back substitution.)

Ta kí hiệu ma trận \(\bm{A}\) khởi đầu là \(\bm{A}^{(1)}\). Sau khi kết thúc
bước khử \(x_i\), ma trận \(\bm{A}^{(i)}\) sẽ biến đổi thành \(\bm{A}^{(i +
1)}\). Bước cuối cùng là bước khử \(x_{n - 1}\) (vì \(x_n\) không cần khử), và
ma trận sau cùng là \(\bm{A}^{(n)}\).

Xem xét kĩ hơn, ta thấy \eqref{eq:gauss_elinimation_1st} có một chi tiết nhạy
cảm là phép chia. Nếu \(a_{11} = 0\), phương pháp không thể thực hiện được, cho
dù thực tế hệ phương trình có thể có nghiệm. Một cách xử lí trường hợp này là
\emph{đổi vị trí hàng}, như trong hai ví dụ sau:

\begin{exmp}\label{exmp:3.1}
    Hãy giải hệ phương trình:
    % TODO: left brace before align?
    \begin{align}
               8x_2 + 2x_3 & = -7 \tag{\(E_1\)} \\
        3x_1 + 5x_2 + 2x_3 & =  8 \tag{\(E_2\)} \\
        6x_1 + 2x_2 + 8x_3 & = 26 \tag{\(E_3\)}
    \end{align}

    Chúng ta xoay trục từ \(E_1\), nhưng do \(E_1\) không có ẩn \(x_1\), trong
    khi đó hệ số của \(x_1\) trong phương trình \(E_3\) là lớn nhất. Vì vậy ta
    đổi chỗ \(E_1\) và \(E_3\) cho nhau.

    Tới đây ta có ma trận mở rộng như sau:
    \[
        \bm{\tilde{A}} =
            \begin{pNiceArray}{ *{3}{ S[table-format=1] } : S[table-format=-1] }
                6  &  2  &  8  &  26  \\
                3  &  5  &  2  &   8  \\
                   &  8  &  2  &  -7
            \end{pNiceArray}
    \]

    \begin{multicols}{2}
        Khử \(x_1\) được:
        \[
            \bm{\tilde{A}}^{(1)} =
                \begin{pNiceArray}{ *{2}{ S[table-format=1] } S[table-format=-1] : S[table-format=-1] }
                    6  &  2  &   8  &  26  \\
                       &  4  &  -2  &  -5  \\
                       &  8  &   2  &  -7
                \end{pNiceArray}
        \]

        Khử \(x_2\) được:
        \[
            \bm{\tilde{A}}^{(2)} =
                \begin{pNiceArray}{ *{2}{ S[table-format=1] } S[table-format=-1] : S[table-format=-1] }
                    6  &  2  &   8  &  26  \\
                       &  4  &  -2  &  -5  \\
                       &     &   6  &   3
                \end{pNiceArray}
        \]
    \end{multicols}

    Vậy ta giải được \(x_3 = \num{0.5}\), \(x_2 = -1\), \(x_1 = 4\).
\end{exmp}

\begin{exmp}
    Hãy giải hệ phương trình:
    \begin{alignat}{11}
         &x_1 &{}-{}&  &x_2 &{}+{}& 2&x_3 &{}-{}&  &x_4 &{}=  -8  \tag{\(E_1\)} \\
        2&x_1 &{}-{}& 2&x_2 &{}+{}& 3&x_3 &{}-{}& 3&x_4 &{}= -20  \tag{\(E_2\)} \\
         &x_1 &{}+{}&  &x_2 &{}+{}&  &x_3 &{} {}&  &    &{}=  -2  \tag{\(E_3\)} \\
         &x_1 &{}-{}&  &x_2 &{}+{}& 4&x_3 &{}+{}& 3&x_4 &{}=   4  \tag{\(E_4\)}
    \end{alignat}

    Ta có ma trận mở rộng như sau:
    \[
        \bm{\tilde{A}} = \bm{\tilde{A}}^{(1)} =
            \begin{pNiceArray}{ *{2}{ S[table-format=1] S[table-format=-1] } : S[table-format=-2] }
                1  &  -1  &  2  &  -1  &   -8  \\
                2  &  -2  &  3  &  -3  &  -20  \\
                1  &   1  &  1  &   0  &   -2  \\
                1  &  -1  &  4  &   3  &    4
            \end{pNiceArray}
    \]

    Khử \(x_1\) bằng chuỗi biến đổi
    \[E_2 \coloneqq E_2 - 2E_1; \, E_3 \coloneqq E_3 - E_1; \, E_4 \coloneqq E_4 - E_1\]
    cho kết quả:
    \[
        \bm{\tilde{A}}^{(2)} =
            \begin{pNiceArray}{ S[table-format=1] *{3}{ S[table-format=-1] } : S[table-format=-1] }
                1  &  -1  &   2  &  -1  &  -8  \\
                0  &   0  &  -1  &  -1  &  -4  \\
                0  &   2  &  -1  &   1  &   6  \\
                0  &   0  &   2  &   4  &  12
            \end{pNiceArray}
    \]

    Điểm quay \(a_{22}^{(2)} = 0\), do đó cần phải đổi hàng. Ta chọn
    \(a_{32}^{(2)} \neq 0\), do đó đổi chỗ \(E_2\) và \(E_3\):
    \[
        \bm{\tilde{A}}^{(2)} =
            \begin{pNiceArray}{ S[table-format=1] *{3}{ S[table-format=-1] } : S[table-format=-1] }
                1  &  -1  &   2  &  -1  &  -8  \\
                0  &   2  &  -1  &   1  &   6  \\
                0  &   0  &  -1  &  -1  &  -4  \\
                0  &   0  &   2  &   4  &  12
            \end{pNiceArray}
    \]

    Do \(x_2\) đã được khử khỏi \(E_3\) và \(E_4\), ta có:
    \[
        \bm{\tilde{A}}^{(3)} = \bm{\tilde{A}}^{(2)} =
            \begin{pNiceArray}{ S[table-format=1] *{3}{ S[table-format=-1] } : S[table-format=-1] }
                1  &  -1  &   2  &  -1  &  -8  \\
                0  &   2  &  -1  &   1  &   6  \\
                0  &   0  &  -1  &  -1  &  -4  \\
                0  &   0  &   2  &   4  &  12
            \end{pNiceArray}
    \]

    Khử \(x_3\) bằng
    \[E_4 \coloneqq E_4 - (-2) E_3\]
    cho kết quả:
    \[
        \bm{\tilde{A}}^{(4)} =
            \begin{pNiceArray}{ S[table-format=1] *{3}{ S[table-format=-1] } : S[table-format=-1] }
                1  &  −1  &   2  &  −1  &  −8  \\
                0  &   2  &  −1  &   1  &   6  \\
                0  &   0  &  −1  &  −1  &  −4  \\
                0  &   0  &   0  &   2  &   4
            \end{pNiceArray}
    \]

    Vậy ta giải được \(x_4 = 2\), \(x_3 = 2\), \(x_2 = 3\), \(x_1 = -7\).
\end{exmp}

Phương pháp khử Gauss còn có một số biến thể:
\begin{itemize}
    \item Phương pháp Gauss-Jordan: đưa \(\bm{A}\) về dạng đường chéo thay vì
        dạng tam giác trên.

    \item \hyperref[thm:doolittle]{Phương pháp Doolittle},
        \hyperref[method:crout]{phương pháp Crout},
        \hyperref[method:cholesky]{phương pháp Cholesky}: đều dựa trên phân
        tích LU (LU factorization), sẽ giới thiệu ở phần sau.
\end{itemize}

\subsection{Độ phức tạp}

Ta phân tích độ phức tạp của phương pháp khử Gauss:
\begin{itemize}
    \item Có tổng cộng \(n - 1\) bước khử.

    \item Ở bước \(k\), ta khử \(x_k\) trong các phương trình \(E_{> k}\), tổng
        cộng là \(n - k\) phương trình.

    \item Trong mỗi phương trình:
        \begin{itemize}
            \item Có \(1\) phép chia: ví dụ \(\dfrac{a_{i1}}{a_{11}}\) trong
                \eqref{eq:gauss_elinimation_1st}

            \item Có \(n - k + 1\) phép nhân: ví dụ \(\dfrac{a_{i1}}{a_{11}}
                E_1\) trong \eqref{eq:gauss_elinimation_1st}

            \item Có \(n - k + 1\) phép trừ: ví dụ chính
                \eqref{eq:gauss_elinimation_1st}
        \end{itemize}
\end{itemize}

Do đó, tổng số phép tính của phương pháp này là:
\begin{align*}
    C(n) &= \sum_{k = 1}^{n - 1} (n - k) + 2 \sum_{k = 1}^{n - 1} (n - k)(n - k + 1) \\
         &= \sum_{s = 1}^{n - 1} s + 2 \sum_{k = 1}^{n - 1} s(s + 1) \, \text{(with \(s = n - k\))} \\
         &= \frac{1}{2} n(n - 1) + \frac{2}{3} n(n^2 - 1) \\
         &\approx \frac{2}{3} n^3
\end{align*}

Ta nói rằng phương pháp khử Gauss có độ phức tạp \(\mathcal{O} (n^3)\).


%----------------------------------------------------------------------------------------
%	3.3: Phân tích LU và Ma trận nghịch đảo
%----------------------------------------------------------------------------------------

\section{Phân tích LU và Ma trận nghịch đảo}

Chúng ta tiếp tục thảo luận các phương pháp số giải hệ phương trình tuyến tính
\(n\) phương trình, \(n\) ẩn. Trong phần này, ta xem xét ba phương pháp cải tiến
từ \hyperref[method:gauss_elimination]{phương pháp khử Gauss}, cho phép tìm
nghiệm nhanh chóng hơn, gồm \hyperref[thm:doolittle]{phương pháp Doolittle},
\hyperref[method:cholesky]{phương pháp Cholesky}, và
\hyperref[method:crout]{phương pháp Crout}. Cả ba phương pháp đều dựa trên phân
tích LU.

Điểm chung của các phương pháp này là đều cố gắng đưa ma trận hệ số về tích của
các ma trận tam giác trên (\underline{U}pper triangular matrix) và ma trận tam
giác dưới (\underline{L}ower triangular matrix). Hai dạng ma trận này rất hữu
ích vì cho phép tìm \(\bm{x}\) với độ phức tạp \(\mathcal{O} (n^2)\); nếu xét
theo khía cạnh này, phương pháp khử Gauss khác ở điểm là \emph{trực tiếp} biến
đổi về dạng tam giác. Tất nhiên, phần lớn tính toán lại chuyển về việc phân tích
ra dạng ma trận đặc biệt này, và với một số hệ phương trình đặc biệt, độ phức
tạp có thể thấp hơn \(\mathcal{O} (n^3)\).

Ba phương pháp được trình bày trong phần này đều gắn chặt với một kiểu phân tích
ra ma trận tam giác. Vì rất dễ để giải nghiệm từ dạng tam giác, nên tên phương
pháp vừa chỉ phương pháp phân tích ra dạng tam giác tương ứng, vừa chỉ phương
pháp giải hệ tuyến tính từ dạng tam giác đã phân tích.

\subsection{Phân tích LU \& phương pháp Doolittle}

\begin{cdefinition}{Phân tích LU (LU factorization)}{lu_factorization}
    Phân tích LU là việc phân tích ma trận vuông \(\bm{A}\) thành tích hai ma
    trận
    \[\bm{A} = \bm{LU}\]
    trong đó \(\bm{L}\) là ma trận tam giác dưới và \(\bm{U}\) là ma trận tam
    giác trên.
\end{cdefinition}

Một số lưu ý về phân tích LU:
\begin{itemize}
    \item Không phải mọi ma trận vuông đều có phân tích LU. Tuy nhiên, ta thừa
        nhận một kết quả quan trọng là mọi ma trận khả nghịch \(\bm{A}_0\) đều
        có thể sắp xếp lại các hàng để thu được một ma trận \(\bm{A}\) có phân
        tích LU.

    \item Có thể có nhiều cách phân tích LU.
\end{itemize}

Sau đây ta tìm hiểu phương pháp Doolittle để phân tích LU. Ta sẽ xem xét kết quả
của phương pháp phân tích LU này với bài toán giải hệ phương trình tuyến tính
trước, sau đó mới đi sâu vào công thức toán học của nó.

\subsubsection{Phương pháp Doolittle: Dùng dạng LU để giải hệ tuyến tính}

Định lí sau đây cũng chính là công thức cho phương pháp Doolittle.

\begin{ctheorem}{}{doolittle}
    Nếu hệ tuyến tính \(\bm{Ax} = \bm{b}\) có thể giải được bằng
    \hyperref[method:gauss_elimination]{khử Gauss} mà không cần đổi vị trí hàng,
    thì \(\bm{A}\) có thể phân tích thành tích của ma trận tam giác trên
    \(\bm{L}\) và tam giác dưới \(\bm{U}\) (tức \(\bm{A} = \bm{LU}\)) với dạng
    sau:
    \[
        \bm{U} =
            \begin{pmatrix}
                a_{11}^{(1)}  &  a_{12}^{(1)}  &  \dots   &  a_{1n}^{(1)}  \\
                              &  a_{22}^{(2)}  &  \dots   &  a_{2n}^{(2)}  \\
                              &                &  \ddots  &     \vdots     \\
                              &                &          &  a_{nn}^{(n)}  \\
            \end{pmatrix}
        \text{, và }
        \bm{L} =
            \begin{pmatrix}
                    1   &          &                &     \\
                m_{21}  &     1    &                &     \\
                \vdots  &  \ddots  &     \ddots     &     \\
                m_{n1}  &  \dots   &  m_{n, n - 1}  &  1  \\
            \end{pmatrix}
    \]
    trong đó
    \begin{itemize}
        \item \(a_{ji}^{k}\) là hệ số của \(x_i\) trong phương trình \(E_j\) tại
            bước khử thứ \(k\)

        \item \(m_{ji} = \dfrac{a_{ji}^{(i)}}{a_{ii}^{(i)}}\) là hệ số của
            \(E_j\) trong, ví dụ, công thức \eqref{eq:gauss_elinimation_1st}.
    \end{itemize}

    \(\bm{U}\) cũng chính là ma trận \(\bm{A}\) thu được sau khi khử Gauss.
\end{ctheorem}

Chú ý rằng \(\bm{U}\) là \(\bm{A}\) sau khi khử Gauss, tức ma trận
\(\bm{\tilde{A}}\) trong phần \ref{sec:gauss_elimination} nhưng bỏ đi cột cuối.

Cần nhắc lại rằng, đến đây, ta vẫn cần giả sử hệ có thể giải được bằng khử Gauss
mà \emph{không} cần đổi vị trí hàng. Mở rộng phương pháp Doolittle cho trường
hợp cần đổi vị trí hàng không khó. Trước hết, ta cần tìm cách biểu diễn việc
tráo đổi vị trí hàng.

\begin{cdefinition}{Ma trận hoán vị (permutation matrix)}{}
    Ma trận hoán vị \(\bm{P}\) là ma trận có được bằng cách sắp xếp lại các hàng
    của \(I\) tùy ý.
\end{cdefinition}

Nhân \(P\) vào bên trái \(A\) sẽ tráo các hàng của \(A\) theo đúng cách tráo các
hàng của \(I\) để tạo ra \(P\). Nói cách khác, \(P\) là tích các ma trận của
\emph{biến đổi sơ cấp tráo hàng (row swapping elementary operation)}.

Ta chọn \(\bm{P}\) sao cho \(\bm{PA}\) có thể giải bằng khử Gauss mà không cần
tráo vị trí hàng. \(\bm{P}\) được xây dựng đơn giản bằng cách áp dụng cách tráo
hàng của Gauss cho ma trận \(\bm{I}\).

\begin{exmp}
    Tìm ma trận hoán vị cho ma trận trong ví dụ \ref{exmp:3.1}, sao cho sau khi
    ma trận đó với ma trận gốc, nhận được một ma trận có thể dùng phương pháp
    khử Gauss.

    Trong ví dụ trên, hệ có thể dùng phương pháp khử Gauss sau khi đổi chỗ
    \(E_1\) và \(E_3\). Vậy một ma trận hoán vị phù hợp là:
    \[
        \bm{P} =
            \begin{pmatrix}
                0  &  0  &  1  \\
                0  &  1  &  0  \\
                1  &  0  &  0  \\
            \end{pmatrix}
    \]
\end{exmp}

Sau khi tìm được \(\bm{P}\), \(\bm{PA}\) có thể áp dụng phương pháp khử Gauss mà
không cần tráo vị trí hàng. Theo định lí \ref{thm:doolittle}, \(\bm{PA}\) có
phân tích LU:
\begin{align*}
        \bm{PA} &= \bm{LU} \\
    \iff \bm{A} &= \bm{P}^{-1} \bm{LU} = (\bm{P}^t \bm{L}) \bm{U} \, \text{(do \(\bm{P}^{-1} = \bm{P}^t\))}
\end{align*}

\subsubsection{Chứng minh phương pháp Doolittle}

Phần này chứng minh kĩ hơn về tính đúng đắn của phương pháp Doolittle, và có thể
bỏ qua.

\begin{proof}[Chứng minh định lí \ref{thm:doolittle}]

    Ta xem xét công thức \eqref{eq:gauss_elinimation_1st}. Xét trường hợp \(j =
    2\):
    \[E_2 \coloneqq E_2 - \frac{a_{21}}{a_{11}} E_1 = E_2 - m_{21} E_1\]

    Sử dụng phép biến đổi sơ cấp cộng một hàng với \(\alpha\) lần một hàng khác
    (row addition elementary operation), ta có ma trận biến đổi sau:
    \[
        \bm{M}_2^{(1)} =
            \begin{pmatrix}
                    1    &     &          &     \\
                -m_{21}  &  1  &          &     \\
                         &     &  \ddots  &     \\
                         &     &          &  1  \\
            \end{pmatrix}
    \]

    Tương tự, cùng trong bước khử đầu tiên (khử \(x_1\)) này, ta có dạng tổng
    quát hơn của \(\bm{M}_j^{(1)}\):
    \[
        \bm{M}_j^{(1)} =
            \begin{pmatrix}
                1        &     &          &     \\
                         &  1  &          &     \\
                -m_{j1}  &     &  \ddots  &     \\
                         &     &          &  1  \\
            \end{pmatrix}
    \]

    Sau khi kết thúc bước khử \(x_1\), \(\bm{A}\) được biến đổi thành
    \[
        \bm{M}_2^{(1)} \bm{M}_3^{(1)} \ldots \bm{M}_n^{(1)} \bm{A} = \bm{M}^{(1)} \bm{A} = \bm{M}^{(1)} \bm{A}^{(1)} = \bm{A}^{(2)}
    \]
    và hơn nữa
    \[
        \bm{A}^{(2)} \bm{x} = \bm{M}^{(1)} \bm{A} \bm{x} = \bm{M}^{(1)} \bm{b} = \bm{b}^{(2)}
    \]

    Dễ dàng chứng minh được \(\bm{M}^{(1)}\) ở trên, gọi là ma trận biến đổi
    Gauss thứ nhất, có dạng sau:
    \[
        \bm{M}^{(1)} =
            \begin{pmatrix}
                    1    &     &          &     \\
                -m_{21}  &  1  &          &     \\
                \vdots   &     &  \ddots  &     \\
                -m_{n1}  &     &          &  1  \\
            \end{pmatrix}
    \]

    Tương tự, ta chứng minh được \(\bm{M}^{k}\) (ma trận biến đổi Gauss thứ
    \(k\)) có dạng sau:
    \[
        \bm{M}^{(k)} =
            \begin{pmatrix}
                1  &          &                 &          &          &     \\
                   &  \ddots  &                 &          &          &     \\
                   &          &        1        &          &          &     \\
                   &          &  -m_{k + 1, k}  &  \ddots  &          &     \\
                   &          &      \vdots     &          &  \ddots  &     \\
                   &          &  -m_{n, k}      &          &          &  1  \\
            \end{pmatrix}
    \]

    Cuối cùng, sau khi kết thúc bước khử \(x_n\):
    \[
        \bm{M}^{(1)} \bm{M}^{(2)} \ldots \bm{M}^{(n)} \bm{A} = \bm{M} \bm{A} = \bm{A}^{(n)}
    \]
    trong đó \(\bm{A}^{(n)}\) chính là ma trận \(\bm{A}\) sau khi khử Gauss:
    \[
        \bm{A}^{(n)} =
            \begin{pmatrix}
                a_{11}^{(1)}  &  a_{12}^{(1)}  &  \dots   &  a_{1n}^{(1)}  \\
                              &  a_{22}^{(2)}  &  \dots   &  a_{2n}^{(2)}  \\
                              &                &  \ddots  &     \vdots     \\
                              &                &          &  a_{nn}^{(n)}  \\
            \end{pmatrix}
    \]

    Tới đây, chúng ta đã biến đổi được phương trình ban đầu
    \eqref{eq:general_system_equations_in_matrix} sang dạng sau:
    \begin{equation}\label{eq:general_system_equations_in_matrix_transformed}
        \bm{A}^{(n)} \bm{x} = \bm{M}^{(n - 1)} \bm{A}^{(n - 1)} \bm{x} = \bm{M}^{(n - 1)} \bm{b}^{(n - 1)} = \bm{b}^{(n)}
    \end{equation}
    trong đó \(\bm{A}^{(n)}\) là một ma trận tam giác trên.

    Giờ đây, nếu coi \(\bm{A}^{(n)}\) là thành phần \(\bm{U}\) cần tìm, ta cần
    nhân vào trước hai vế của
    \eqref{eq:general_system_equations_in_matrix_transformed} một thành phần
    \(\bm{L}\) nào đó để đưa
    \eqref{eq:general_system_equations_in_matrix_transformed} về lại
    \eqref{eq:general_system_equations_in_matrix}.

    Thành phần \(\bm{U}\) đã thấy chỉ đơn giản là \(\bm{A}\) qua một chuỗi các
    biến đổi sơ cấp cộng một hàng với \(\alpha\) lần một hàng khác. Do đó
    \(\bm{L}\) chỉ cần là một ma trận có thể đảo ngược chuỗi biến đổi này.

    Xét biến đổi \(\bm{M}_2^{(1)}\), biến đổi
    \[
        \bm{L}_2^{(1)} =
            \begin{pmatrix}
                    1   &     &          &     \\
                m_{21}  &  1  &          &     \\
                        &     &  \ddots  &     \\
                        &     &          &  1  \\
            \end{pmatrix}
    \]
    sẽ đảo ngược được \(\bm{M}_2^{(1)}\). Lý do cũng rất đơn giản:
    \begin{itemize}
        \item \(\bm{M}_2^{(1)}\) lấy \(E_2\) trừ đi \(m_{21}\) lần \(E_1\), thì
        \item \(\bm{L}_2^{(1)}\) lấy \(E_2\) cộng với \(m_{21}\) lần \(E_1\)
    \end{itemize}

    Tương tự, ta dễ dàng thấy
    \[
        \bm{L}^{(k)} =
            \begin{pmatrix}
                1  &          &                &          &          &     \\
                   &  \ddots  &                &          &          &     \\
                   &          &        1       &          &          &     \\
                   &          &  m_{k + 1, k}  &  \ddots  &          &     \\
                   &          &     \vdots     &          &  \ddots  &     \\
                   &          &  m_{n, k}      &          &          &  1  \\
            \end{pmatrix}
    \]
    sẽ đảo ngược được \(\bm{M}^{(k)}\).

    Nhân \(\bm{L}^{(k)}\) vào trước hai vế của
    \eqref{eq:general_system_equations_in_matrix_transformed} theo thứ tự \(k\)
    tăng dần từ \(1\) đến \(n - 1\), ta có:
    \[\begin{split}
                                                       \bm{L}^{(1)} \bm{L}^{(2)} \ldots \bm{L}^{(n - 1)} \bm{A}^{(n)} \bm{x} &= \bm{L}^{(1)} \bm{L}^{(2)} \ldots \bm{L}^{(n - 1)} \bm{b}^{(n)} \\
            \iff \bm{L}^{(1)} \bm{L}^{(2)} \ldots \bm{L}^{(n - 1)} \bm{M}^{(n - 1)} \ldots \bm{M}^{(2)} \bm{M}^{(1)} \bm{Ax} &= \bm{L}^{(1)} \bm{L}^{(2)} \ldots \bm{L}^{(n - 1)} \\
                                                                                                                             & \bm{M}^{(n - 1)} \ldots \bm{M}^{(2)} \bm{M}^{(1)} \bm{b} \\
                                                                                                                \iff \bm{Ax} &= \bm{b}
    \end{split}\]

    Đến đây, ta nhận được phương trình
    \eqref{eq:general_system_equations_in_matrix} ban đầu. Vậy tích các
    \(\bm{L}^{(k)}\) theo thứ tự trên là một giá trị \(\bm{L}\) phù hợp. Không
    khó để chứng minh rằng:
    \[
        \bm{L} = \bm{L}^{(1)} \bm{L}^{(2)} \ldots \bm{L}^{(n - 1)} =
            \begin{pmatrix}
                    1   &          &                &          &                &     \\
                m_{21}  &  \ddots  &                &          &                &     \\
                \vdots  &  \ddots  &        1       &          &                &     \\
                \vdots  &  \vdots  &  m_{k + 1, k}  &  \ddots  &                &     \\
                \vdots  &  \vdots  &     \vdots     &  \ddots  &     \ddots     &     \\
                m_{n1}  &  \dots   &  m_{n, k}      &  \dots   &  m_{n, n - 1}  &  1  \\
            \end{pmatrix}
    \]

    Vậy ta đã xây dựng được phân tích LU của \(\bm{A}\), với \(\bm{L}\) và
    \(\bm{U}\) có dạng như yêu cầu.

\end{proof}

\newcommand{\LLt}{LL\textsuperscript{t}}
\subsection{Phân tích \texorpdfstring{\LLt}{} và phương pháp Cholesky}

Thuật toán Cholesky phân tích một ma trận xác định dương ra dạng \LLt. Để tìm
hiểu phân tích này, ta cần biết về ma trận xác định dương.

\begin{cdefinition}{Ma trận xác định dương (positive definitive matrix)}{}
    Ma trận \(\bm{A}\) \(n \times n\) gọi là xác định dương nếu:
    \begin{itemize}
        \item \(\bm{A}\) đối xứng, và
        \item \(\bm{x}^t \bm{A} \bm{x} > 0 \, \forall \bm{x} \neq 0\)
    \end{itemize}
\end{cdefinition}

\(\bm{L}\) có dạng như sau (viết rõ lại để tiện biểu diễn về sau):
\[
    \bm{L} =
        \begin{pmatrix}
            l_{11}  &          &          &        \\
            l_{21}  &  l_{22}  &          &        \\
            \vdots  &  \vdots  &  \ddots  &        \\
            l_{n1}  &  \dots   &  \dots   &  l_{nn}\\
        \end{pmatrix}
\]

Ta thừa nhận định lí sau:

\begin{ctheorem}{}{}
    Ma trận \(\bm{A}\) là xác định dương khi và chỉ khi nó phân tích được ra
    dạng \(\bm{L} \bm{L}^t\), trong đó \(\bm{L}\) là ma trận tam giác dưới với
    đường chéo chính khác \(0\).
\end{ctheorem}

Do có số ẩn không lớn (với ma trận \(n \times n\) cần tìm tổng cộng \(\frac{n(n
+ 1)}{2}\) ẩn), đồng thời ma trận tích có dạng phù hợp, nên phương pháp này có
thể giải bằng tay các ẩn theo cách thế thông thường với \(n\) nhỏ. Nếu không
tiện tính tay, ta có phương pháp chính xác sau:

\begin{cmethod}{Phương pháp Cholesky}{cholesky}
    Phương pháp Cholesky phân tích ma trận xác định dương \(\bm{A}\) thành dạng
    \LLt.

    Lần lượt tính phần tử khác \(0\) ở cột \(1\), \(2\), \ldots. Bước thứ \(i\)
    sẽ tính các phần tử thuộc cột \(i\) như sau:
    \begin{itemize}
        \item Tính \(l_{ii}\):
            \[l_{ii} = \left(a_{ii} - \sum_{k = 1}^{i - 1} l_{ik}^2\right)^{\num{0.5}}\]

        \item Tính các phần tử còn lại, nếu có:
            \[l_{ji} = \frac{1}{l_{ii}} \left(a_{ji} - \sum_{k = i + 1}^{n} l_{jk} l_{ik}\right) \mid j \in \interval{i + 1}{n}\]
    \end{itemize}
\end{cmethod}

\subsection{Phân tích LU cho ma trận dải \& thuật toán Crout}

Ta quay trở lại với phân tích LU, tuy nhiên sử dụng thuật toán khác, nhanh vượt
trội so với Doolittle, cho một loại ma trận đặc biệt: ma trận dải.

\begin{cdefinition}{Ma trận dải (band matrix)}{}
    Ma trận \(n \times n\) gọi là ma trận dải nếu có \(1 < p \text{, } q < n\)
    sao cho \(a_{ij} = 0\) khi \(j - i \geq p\) hoặc \(i - j \geq q\).
\end{cdefinition}

Nói cách khác, hai chỉ số \(p\), \(q\) chỉ số đường chéo mà các phần tử trên đó
không nhất thiết bằng \(0\):
\begin{itemize}
    \item \(p\) đường chéo trên đường chéo chính, gồm cả đường chéo chính
    \item \(q\) đường chéo dưới đường chéo chính, gồm cả đường chéo chính
\end{itemize}

Ta lại xét tiếp một trường hợp đặc biệt: ma trận dải với \(p = q = 2\), gọi là
\emph{ma trận ba đường chéo (tridiagonal matrix)}.

Nếu \(\bm{A}\) trong \eqref{eq:general_system_equations_in_matrix} có dạng ba
đường chéo:
\[
    \bm{A} =
        \begin{pmatrix}
            a_{11}  &  a_{12}  &          &                &                \\
            a_{21}  &  a_{22}  &  a_{23}  &                &                \\
                    &  a_{32}  &  a_{33}  &     \ddots     &                \\
                    &          &  \ddots  &     \ddots     &  a_{n - 1, n}  \\
                    &          &          &  a_{n, n - 1}  &     a_{nn}     \\
        \end{pmatrix}
\]
thì có thể phân tích \(\bm{A}\) ra dạng LU như sau:
\[
    \bm{L} =
        \begin{pmatrix}
            l_{11}  &          &          &                &          \\
            l_{21}  &  l_{22}  &          &                &          \\
                    &  l_{32}  &  l_{33}  &                &          \\
                    &          &  \ddots  &     \ddots     &          \\
                    &          &          &  l_{n, n - 1}  &  l_{nn}  \\
        \end{pmatrix}
    \, \text{, và }
    \bm{U} =
        \begin{pmatrix}
            1  &  u_{12}  &          &          &                \\
               &    1     &  u_{23}  &          &                \\
               &          &  \ddots  &  \ddots  &                \\
               &          &          &  \ddots  &  u_{n - 1, n}  \\
               &          &          &          &     1          \\

        \end{pmatrix}
\]

Do có số ẩn không lớn (với ma trận \(n \times n\) cần tìm tổng cộng \(3n - 2\)
ẩn), đồng thời ma trận tích có dạng phù hợp, nên phương pháp này có thể giải
bằng tay các ẩn theo cách thế thông thường với \(n\) nhỏ. Nếu không tiện tính
tay, ta giới thiệu qua phương pháp sau:

\begin{cmethod}{Phương pháp Crout cho ma trận ba đường chéo}{crout}
    Phương pháp Crout dùng để phân tích ma trận ra dạng LU. Dạng LU của phương
    pháp Crout có khác biệt so phương pháp Doolittle:
    \begin{itemize}
        \item Phương pháp Crout tạo ma trận \(\bm{U}\) có đường chéo chính bằng
            \(1\).
        \item Phương pháp Doolittle tạo ma trận \(\bm{L}\) có đường chéo chính
            bằng \(1\).
    \end{itemize}
\end{cmethod}


%----------------------------------------------------------------------------------------
%	3.4: Các phương pháp lặp
%----------------------------------------------------------------------------------------

\section{Các phương pháp lặp}

\hyperref[method:gauss_elimination]{Phương pháp khử Gauss} và các biến thể của
nó trong hai phần cuối cùng là các \emph{phương pháp trực tiếp} để giải hệ
phương trình tuyến tính; đây là những phương pháp đưa ra nghiệm sau một số tính
toán được xác định trước. Ngược lại, trong trường hợp \emph{giải gián tiếp} hoặc
\emph{phương pháp lặp (iterative method)} chúng ta bắt đầu từ một giá trị xấp xỉ
nghiệm đúng và, nếu thành công, sẽ có được xấp xỉ tốt hơn và tốt hơn từ một quá
trình tính toán lặp đi lặp lại. Trong các phương pháp này, số phép tính phụ
thuộc vào độ chính xác cần thiết.

Chúng ta áp dụng các phương pháp lặp nếu tốc độ hội tụ đủ nhanh (nếu ma trận có
các phần tử nằm trên đường chéo chính lớn hơn các phần tử nằm ngoài, như ta sẽ
thấy), hoặc với \emph{ma trận thưa (sparse matrix)}, tức ma trận có phần lớn các
phần tử là \(0\).

\subsection{Phương pháp lặp Gauss - Seidel}

Đây là một phương pháp lặp quan trọng, được nghiên cứu và sử dụng nhiều. Trước
khi đi vào công thức chi tiết, ta xem xét phương pháp qua ví dụ sau:

\begin{exmp}\label{exmp:3.4}
    Xét hệ phương trình
    % Tried & failed (or not elegant)
    % \[   % atm systeme has a problem with this
    %     \systeme{    % * means not aligning variables
    %                     x_1 - \num{0.25} x_2 - \num{0.25} x_3                  = 50,
    %         \num{-0.25} x_1 +            x_2 -                  \num{0.25} x_4 = 50,
    %         \num{-0.25} x_1 +                             x_3 - \num{0.25} x_4 = 25,
    %                          \num{-0.25} x_2 - \num{0.25} x_3 +            x_4 = 25    % No comma at the end!
    %     }
    % \]
    % \begin{empheq}[left = \empheqlbrace]{alignat* = 5}
    %                 x_1 &{}-{}& \num{0.25} x_2 &{}-{}& \num{0.25} x_3 &     &                &= 50  \\
    %     \num{-0.25} x_1 &{}+{}&            x_2 &     &                &{}-{}& \num{0.25} x_4 &= 50  \\
    %     \num{-0.25} x_1 &{}+{}&                &     &            x_3 &{}-{}& \num{0.25} x_4 &= 25  \\
    %                     &{}-{}& \num{0.25} x_2 &{}-{}& \num{0.25} x_3 &{}+{}&            x_4 &= 25    % No \\ here
    % \end{empheq}
    \[
        \left\{
            \setlength{\arraycolsep}{0pt}%
            \renewcommand{\arraystretch}{1.2}%
            \begin{array}{ *{5}{ r >{ {} } c <{ {} } } r }
                % *{5}{                    5 of anything in the next brace
                %     r                    right align (for the operand)
                %     >{ {} }              put {} before the content of every cell in column
                %         c                center (for the operator)
                %     <{ {} }              put {} after the content of every cell in column
                % }
                % r
                            x_1 &-& \num{0.25} x_2 &-& \num{0.25} x_3 & &                &=& 50  \\
                \num{-0.25} x_1 &+&            x_2 & &                &-& \num{0.25} x_4 &=& 50  \\
                \num{-0.25} x_1 &+&                & &            x_3 &-& \num{0.25} x_4 &=& 25  \\
                                &-& \num{0.25} x_2 &-& \num{0.25} x_3 &+&            x_4 &=& 25    % No \\ here
            \end{array}
        \right.    % Placeholder dot
    \]

    Viết lại hệ theo cách sau:
    \begin{equation*}\tag{1}\label{eq:exmp_3.4}
        \left\{
            \setlength{\arraycolsep}{0pt}%
            \renewcommand{\arraystretch}{1.2}%
            \begin{array}{ *{5}{ r >{ {} } c <{ {} } } r }
                x_1 &=&                && \num{0.25} x_2 &+& \num{0.25} x_3 & &                &+& 50  \\
                x_2 &=& \num{0.25} x_1 &&                & &                &+& \num{0.25} x_4 &+& 50  \\
                x_3 &=& \num{0.25} x_1 &&                & &                &+& \num{0.25} x_4 &+& 25  \\
                x_4 &=&                && \num{0.25} x_2 &+& \num{0.25} x_3 & &                &+& 25
            \end{array}
        \right.
    \end{equation*}

    Ta bắt đầu bằng một xấp xỉ (cho dù có thể khác xa nghiệm cần tìm), ví dụ
    \(x_1^{(0)} = x_2^{(0)} = x_3^{(0)} = x_4^{(0)} = 100\) và tính \(\bm{x}^{(1)}\)
    từ các giá trị này, theo công thức \eqref{eq:exmp_3.4} như sau:
    \[
        % Color
        \colorlet{old}{green!30}
        \colorlet{new}{blue!30}
        % Cell color
        \newcommand\old{\cellcolor{old}}    % Mark old value
        \newcommand\new{\cellcolor{new}}    % Mark new value
        % Spacing
        \setlength{\arraycolsep}{0pt}%
        \renewcommand{\arraystretch}{1.5}%
        \begin{array}{ *{5}{ r >{ {} } c <{ {} } } r l }
                                                                       \multicolumn{9}{r}{\text{Giá trị cũ (chưa có giá trị mới) \(\downarrow\)}}  & &                \\
            x_1^{(1)} &=&                          && \num{0.25} x_2^{(0)} \old&+ \old& \num{0.25} x_3^{(0)} \old&  \old&                      \old&+& 50 &{}= 100    \\
            x_2^{(1)} &=& \num{0.25} x_1^{(1)} \new&&                          &  \old&                      \old&+ \old& \num{0.25} x_4^{(0)} \old&+& 50 &{}= 100    \\
            x_3^{(1)} &=& \num{0.25} x_1^{(1)} \new&&                      \new&      &                          &+ \old& \num{0.25} x_4^{(0)} \old&+& 25 &{}= 75     \\
            x_4^{(1)} &=&                      \new&& \num{0.25} x_2^{(1)} \new&+ \new& \num{0.25} x_3^{(1)} \new&      &                    &+& 25 &{}= \num{68.75}  \\
                      & & \multicolumn{10}{l}{\text{\(\uparrow\) Giá trị mới}}
        \end{array}
    \]

    Trong tính toán trên, \(\bm{x}^{(1)}\) được tính theo công thức
    \eqref{eq:exmp_3.4}, nhưng với các giá trị \(x\) mới nhất có được ở thời
    điểm tính toán. Tiếp tục tính toán, ta có bảng sau:
    \begin{table}[H]
        \centering
        \begin{tabular}{ r *{4}{ S[table-format=2.3] } }
            \toprule
            \(k\)  &  \(x_1^{(k)}\)  &  \(x_2^{(k)}\)  &  \(x_3^{(k)}\)  &  \(x_4^{(k)}\)  \\
            \midrule
                1  &         89.062  &         88.281  &         63.281  &         62.891  \\
                2  &         87.891  &         87.695  &         62.695  &         62.598  \\
                3  &         87.598  &         87.549  &         62.549  &         62.524  \\
                4  &         87.524  &         87.512  &         62.512  &         62.506  \\
                5  &         87.506  &         87.503  &         62.503  &         62.502  \\
            \bottomrule
        \end{tabular}
    \end{table}

    Rõ ràng, nghiệm hội tụ rất nhanh.
\end{exmp}

\subsubsection{Phương pháp Gauss-Seidel}

Ta đã thấy Gauss-Seidel, cũng giống như \hyperref[chapter2:method:newton]{phương
pháp Newton} hay \hyperref[chapter2:method:fixed_point]{phương pháp điểm bất
động}, là một phương pháp lặp (iterative method), tức tính một hàm lặp đi lặp
lại, kết quả lần lặp trước là đầu vào của lần lặp sau. Trong phần này, ta sẽ đưa
ra công thức lặp Gauss-Seidel theo một cách trực quan từ ví dụ \ref{exmp:3.4}.

Ví dụ \ref{exmp:3.4} thực hiện được dễ dàng nhất khi hệ số của \(x_i\) trong
phương trình thứ \(i\) là \(1\), tức đường chéo chính của \(\bm{A}\) chỉ chứa
\(1\). Để tiện trong việc đưa ra công thức, ta giả sử rằng \(a_{jj} = 1 \,
\forall j \in \interval{1}{n}\), do mọi hệ phương trình có thể đưa được về dạng
này, thông qua các biến đổi hàng sơ cấp.

Ta tách \(\bm{A}\) như sau:
\[\bm{A} = \bm{I} + \bm{L} + \bm{U}\]
trong đó \(\bm{I}\) là ma trận đơn vị, \(\bm{L}\) là ma trận tam giác dưới chặt
(strictly), \(\bm{U}\) là ma trận tam giác trên chặt.

Thay vào \eqref{eq:general_system_equations_in_matrix}, ta có:
\begin{gather*}
    \bm{Ax} = (\bm{I} + \bm{L} + \bm{U}) \bm{x} = \bm{b} \\
    \iff \bm{x} = \bm{b} -\bm{Lx} - \bm{Ux}
\end{gather*}

Theo ví dụ \ref{exmp:3.4}, ta thấy \(\bm{U}\) chứa các giá trị \(x\) cũ, còn
\(\bm{L}\) chứa các giá trị \(x\) mới. Từ đó, ta có công thức lặp tổng quát:
\begin{equation}\label{eq:gauss-seldel_sequence_function}
    \bm{x}^{(m + 1)} = \bm{b} - \bm{L} \bm{x}^{(m + 1)} - \bm{U} \bm{x}^{(m)}
\end{equation}
trong đó \(\bm{x}^{(m)}\) là véc tơ nghiệm xấp xỉ thứ \(m\).

\begin{cmethod}{Phương pháp Gauss-Seidel}{gauss-seidel}
    Phương pháp này xấp xỉ nghiệm \(\bm{x}\) của hệ \(\bm{Ax} = \bm{b}\) khi
    \begin{itemize}
        \item biết xấp xỉ bắt đầu \(\bm{x}^{(0)}\), và
        \item \(\bm{A}\) không chứa \(0\) trên đường chéo chính
    \end{itemize}

    Gọi các phương trình trong hệ là \(E_i\). Ta đưa hết \(x_i\) sang riêng vế
    trái của \(E_i\) sao cho hệ số của \(x_i\) là \(1\). Nói cách khác, ta tính
    \(x_i\) qua các \(x_j\), \(j \neq i\).

    Phương pháp Gauss-Seidel thực hiện như sau:
    \begin{enumerate}
        \item Trong mỗi lần lặp, tính \(\bm{x}\) như sau:
            \begin{itemize}
                \item lần lượt tính \(x_i\) theo thứ tự \(i\) tăng dần như công
                    thức đã tách vế trái ở trên, và
                \item dùng giá trị \(x_j\) với mới nhất có thể khi tính \(x_i\)
            \end{itemize}
        \item Dừng lại khi đạt điều kiện dừng, nếu không lặp lại bước trên
    \end{enumerate}
\end{cmethod}

Chú ý rằng, phương pháp trên chỉ cần điều kiện đường chéo chính của \(\bm{A}\)
không chứa \(0\). Điều kiện đường chéo chính chứa toàn \(1\) được bỏ qua vì
trong bước đưa \(x_i\) sang vế trái của \(E_i\), hệ số của \(x_i\) đã được
chuyển thành \(1\).

\subsubsection{Điều kiện hội tụ}

Ta viết lại \eqref{eq:gauss-seldel_sequence_function} như sau:
\begin{gather*}
    \bm{x}^{(m + 1)} = \bm{b} - \bm{L} \bm{x}^{(m + 1)} - \bm{U} \bm{x}^{(m)} \\
    \iff (\bm{I} + \bm{L})\bm{x}^{(m + 1)} = \bm{b} - \bm{U} \bm{x}^{(m)} \\
    \iff \bm{x}^{(m + 1)} = \bm{C} \bm{x}^{(m)} + (\bm{I} + \bm{L})^{-1} \bm{b} \text{ với } \bm{C} = -(\bm{I} + \bm{L})^{-1} \bm{U}
\end{gather*}

Chú ý rằng, nếu muốn tính \(\bm{C}\) theo công thức trên, \(\bm{A}\) phải ở dạng
đường chéo chính chứa toàn \(1\).

Trước hết ta nhớ lại định nghĩa về \emph{véc tơ riêng} và
\emph{giá trị riêng} của ma trận:

\begin{cdefinition}{Véc tơ riêng (eigenvector) \& giá trị riêng (eigenvalue)}{}
    Với mỗi ma trận \(\bm{A}\), véc tơ \(\bm{v} \neq \vec{0}\) và vô hướng
    \(\lambda\) được gọi lần lượt là véc tơ riêng và giá trị riêng ứng với véc
    tơ riêng đó nếu:
    \[\bm{Av} = \lambda \bm{v}\]
\end{cdefinition}

Ta thừa nhận một kết quả quan trọng để tính các giá trị riêng; sau khi đã có các
giá trị riêng, ta có thể dễ dàng tìm các véc tơ riêng tương ứng:
\[\det(\bm{A} - \lambda \bm{I}) = 0\]

Quay trở lại phương pháp Gauss-Seidel, ta thừa nhận phương pháp này hội tụ khi
và chỉ khi tất cả trị riêng của \(\bm{C}\) có giá trị tuyệt đối nhỏ hơn \(1\).
Cụ thể hơn, ta xét \emph{bán kính phổ} của \(\bm{C}\).

\begin{cdefinition}{Bán kính phổ (spectral radius)}{spectral_radius}
    Bán kính phổ của ma trận \(\bm{C}\) là giá trị tuyệt đối lớn nhất của các
    giá trị riêng của \(\bm{C}\).
\end{cdefinition}

Phương pháp Gauss-Seidel, với bán kính phổ \(r\) của \(\bm{C}\), sẽ hội tụ:
\begin{itemize}
    \item khi và chỉ khi \(r < 1\)
    \item nhanh hơn khi \(r\) nhỏ
\end{itemize}

Như vậy, ta đã biết điều kiện \emph{cần và đủ} để phương pháp Gauss-Seidel hội
tụ. Giờ ta sẽ xem xét một số điều kiện \emph{đủ} cho sự hội tụ này.

Phương pháp Gauss-Seidel sẽ hội tụ khi
\[\norm{\bm{C}} < 1\]

\(\norm{\bm{C}}\) là \emph{chuẩn (norm)} của \(\bm{C}\). Ta có một số chuẩn hay
gặp như sau:
\begin{itemize}
    \item Chuẩn Frobenius, tức căn bậc hai của tổng của bình phương mọi phần tử:
        \[\norm{\bm{C}} = \sqrt{\sum_{j = 1}^n \sum_{k = 1}^n c_{jk}^2}\]

    \item Chuẩn tổng cột, tức giá trị lớn nhất trong tổng các trị tuyệt đối của
        phần tử một cột:
        \[\norm{\bm{C}} = \max_k \sum_{j = 1}^n \abs{c_{jk}}\]

    \item Chuẩn tổng hàng, tức giá trị lớn nhất trong tổng các trị tuyệt đối của
        phần tử một hàng:
        \[\norm{\bm{C}} = \max_j \sum_{k = 1}^n \abs{c_{jk}}\]
\end{itemize}

Ba chuẩn này không tương đương với nhau. Hoàn toàn có thể có trường hợp một
chuẩn thỏa mãn điều kiện trị tuyệt đối nhỏ hơn \(1\), đủ để kết luận phương pháp
hội tụ, nhưng dùng chuẩn khác thì lại không thể kết luận về sự hội tụ.

\subsection{Phương pháp Jacobi}

\hyperref[method:gauss-seidel]{Phương pháp Gauss-Seidel} là một phương pháp
\emph{hiệu chỉnh liên tiếp (successive correction)} vì \emph{trong} mỗi bước
lặp, ta cập nhật giá trị một thành phần \(x_j\) mỗi khi thành phần đó có xấp xỉ
mới. \emph{Phương pháp Jacobi} sẽ giới thiệu dưới đây lại thuộc loại \emph{hiệu
chỉnh đồng thời}, tức khi tính toán chỉ dùng các xấp xỉ cũ, và cập nhật đồng
thời các \(x_j\) ở cuối vòng lặp, sau khi đã tính xong \(x_n\).

Khác biệt về việc sử dụng giá trị xấp xỉ mới nói ở trên là điểm khác biệt chính
yếu của hai phương pháp này. Do đó, ta có thể viết công thức lặp tổng quát cho
phương pháp Jacobi dựa trên \eqref{eq:gauss-seldel_sequence_function} như sau:
\begin{align}
    \begin{aligned}
        \bm{x}^{(m + 1)} &= \bm{b} - \bm{L} \bm{x}^{(m)} - \bm{U} \bm{x}^{(m)} \\
                         &= \bm{b} - (\bm{L} + \bm{U}) \bm{x}^{(m)} \\
                         &= \bm{b} - (\bm{A} - \bm{I}) \bm{x}^{(m)} \\
                         &= \bm{b} + (\bm{I} - \bm{A}) \bm{x}^{(m)} \\
    \end{aligned}
\end{align}

Tiếp tục chú ý, \(\bm{A}\) ở đây vẫn phải ở dạng có đường chéo chính toàn \(1\).

Phương pháp Jacobi sẽ hội tụ với mọi \(\bm{x}^{(0)}\) khi và chỉ khi bán kính
phổ của \(\bm{I} - \bm{A}\) nhỏ hơn \(1\).

Phương pháp Jacobi gần đây được chú ý nhiều vì cho phép tính toán song song. Bản
chất cập nhật lập tức của phương pháp Gauss-Seidel khiến việc song song hóa rất
khó khăn, còn việc cập nhật sau mỗi lần lặp khiến phương pháp Jacobi có thể được
song song hóa vô cùng dễ dàng.

\end{document}
